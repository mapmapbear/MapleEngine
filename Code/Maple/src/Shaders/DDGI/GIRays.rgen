#version 460

#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : require

#include "DDGICommon.glsl"
#include "../Common/Math.h"

layout(location = 0) rayPayloadEXT GIPayload outPayload;

layout(set = 0, binding = 3) uniform accelerationStructureEXT uTopLevelAS;

layout(set = 5, binding = 2, scalar) uniform DDGIUBO
{
    DDGIUniform ddgi;
};

layout(set = 6, binding = 0, rgba16f) uniform image2D iRadiance;

layout(set = 6, binding = 1, rgba16f) uniform image2D iDirectionDistance;

layout(push_constant) uniform PushConstants
{
    mat4  randomOrientation;
    uint  numFrames;
    uint  infiniteBounces;
    int   numLights;
    float intensity;
}pushConsts;




/**
At each of the m active probes, we [uniformly sample] n spherical directions 
according to a stochastically-rotated Fibonacci spiral pattern.
We then spawn n rays with these directions and a (shared) origin of the probe
center. We lay out the rays across the m probes in a thread-coherent fashion, casting
all of them in one batch.
*/
vec3 sphericalFibonacci(float i) 
{
    float n = ddgi.raysPerProbe;
    const float PHI = sqrt(5) * 0.5 + 0.5;

#define madfrac(A, B) ((A) * (B)-floor((A) * (B)))
    float phi       = 2.0 * PI * madfrac(i, PHI - 1);
    float cosTheta = 1.0 - (2.0 * i + 1.0) * (1.0 / n);
    float sinTheta = sqrt(clamp(1.0 - cosTheta * cosTheta, 0.0f, 1.0f));
    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
#undef madfrac
}

void main()
{
    const ivec2 texCoords   = ivec2(gl_LaunchIDEXT.xy);
    const int probeId       = texCoords.y;
    const int rayId         = texCoords.x;

    uint  rayFlags  = 0;//gl_RayFlagsOpaqueEXT;
    uint  cullMask  = 0xff;
    float tmin      = 0.001;
    float tmax      = 10000.0;
    vec3  rayOrigin = probeLocation(ddgi, probeId);
    vec3  direction  = normalize(mat3(pushConsts.randomOrientation) * sphericalFibonacci(rayId));

    outPayload.random = randomInit(texCoords, pushConsts.numFrames);
    outPayload.L = vec3(0.0f);
    outPayload.T = vec3(1.0f);
    outPayload.hitDistance = tmax;

    traceRayEXT(uTopLevelAS, rayFlags, cullMask, 0, 0, 0, rayOrigin, tmin, direction, tmax, 0);

    //get radiance / hitDistance.
    imageStore(iRadiance, texCoords, vec4(outPayload.L, 0.0f));
    imageStore(iDirectionDistance, texCoords, vec4(direction, outPayload.hitDistance));
}

// ------------------------------------------------------------------------