#version 450
#extension GL_GOOGLE_include_directive : require

#define NUM_THREADS_X 8
#define NUM_THREADS_Y 8




#define RAY_MASK_SIZE_X 8
#define RAY_MASK_SIZE_Y 4

layout(local_size_x = NUM_THREADS_X, local_size_y = NUM_THREADS_Y, local_size_z = 1) in;


layout(set = 0, binding = 0, rg16f)     uniform writeonly image2D outColor;
layout(set = 0, binding = 1, rgba16f)   uniform writeonly image2D moment;
layout(set = 0, binding = 2)            uniform sampler2D uHistoryOutput;
layout(set = 0, binding = 3)            uniform sampler2D uHistoryMoments;
layout(set = 0, binding = 4)            uniform usampler2D uInput;

layout(set = 1, binding = 0) uniform sampler2D uPositionSampler;
layout(set = 1, binding = 1) uniform sampler2D uNormalSampler;
layout(set = 1, binding = 2) uniform sampler2D uDepthSampler;
layout(set = 1, binding = 3) uniform sampler2D uVelocitySampler;

layout(set = 2, binding = 0) uniform sampler2D uPrevPositionSampler;
layout(set = 2, binding = 1) uniform sampler2D uPrevNormalSampler;
layout(set = 2, binding = 2) uniform sampler2D uPrevDepthSampler;
layout(set = 2, binding = 3) uniform sampler2D uPrevVelocitySampler;

//Noise Shadow

layout(set = 3, binding = 0, std430) buffer DenoiseTileData
{
    ivec2 coord[];
}denoiseTileData;

layout(set = 3, binding = 1, std430) buffer DenoiseTileDispatchArgs
{
    uint numGroupsX;
    uint numGroupsY;
    uint numGroupsZ;
}denoiseTileDispatchArgs;

layout(set = 3, binding = 2, std430) buffer ShadowTileData
{
    ivec2 coord[];
}shadowTileData;

layout(set = 3, binding = 3, std430) buffer ShadowTileDispatchArgs
{
    uint numGroupsX;
    uint numGroupsY;
    uint numGroupsZ;
}shadowTileDispatchArgs;


layout(push_constant) uniform PushConstants
{
    float alpha;
    float momentsAlpha;
}pushConsts;

shared uint  gShadowHitMasks[3][6];
shared float gMeanAccumulation[8][24];
shared uint  gShouldDenoise;


void loadCache()
{
    if (gl_LocalInvocationID.x < 3 && gl_LocalInvocationID.y < 6)
    {
        ivec2 coord = ivec2(gl_WorkGroupID.x, gl_WorkGroupID.y * 2) - ivec2(1, 2) + ivec2(gl_LocalInvocationID.xy);
        gShadowHitMasks[gl_LocalInvocationID.x][gl_LocalInvocationID.y] = texelFetch(uInput, coord, 0).x;
    }
    barrier();
}


float unpackShadowHitValue(ivec2 coord)
{
    // Find the global coordinate for the top left corner of the current work group.
    const ivec2 workGroupStartCoord = ivec2(gl_WorkGroupID.xy) * ivec2(NUM_THREADS_X, NUM_THREADS_Y);

    // Find the global coordinate for the top left corner of the cache.
    const ivec2 cacheStartCoord = workGroupStartCoord - ivec2(RAY_MASK_SIZE_X, RAY_MASK_SIZE_Y * 2);

    // Compute the local coordinate within the cache for the requested global coordinate.
    const ivec2 unpackedCacheCoord = coord - cacheStartCoord;

    // From the unpacked local coordinate, compute which ray mask the requested hit belongs to.
    // aka the packed local coordinate.
    const ivec2 packedCacheCoord = unpackedCacheCoord / ivec2(RAY_MASK_SIZE_X, RAY_MASK_SIZE_Y);

    // From the packed local coordinate, compute the unpacked local coordinate for the start of the current ray mask.
    const ivec2 maskStartCoord = packedCacheCoord * ivec2(RAY_MASK_SIZE_X, RAY_MASK_SIZE_Y);

    // Find the relative coordinate of the requested sample within the ray mask.
    const ivec2 relativeMaskCoord = unpackedCacheCoord - maskStartCoord;

    // Compute the flattened hit index of the requested sample within the ray mask.
    const int hitIndex = relativeMaskCoord.y * RAY_MASK_SIZE_X + relativeMaskCoord.x;

    // Use the hit index to bit shift the value from the cache and retrieve the requested sample.
    return float((gShadowHitMasks[packedCacheCoord.x][packedCacheCoord.y] >> hitIndex) & 1u);
}


float horizontalMean(ivec2 coord)
{
    float result = 0.0f;

    for (int x = -8; x <= 8; x++)// 17
        result += unpackShadowHitValue(ivec2(coord.x + x, coord.y));

    return result;
}

float computeMean(ivec2 coord)
{
    float top    = horizontalMean(ivec2(coord.x, coord.y - 8));
    float middle = horizontalMean(ivec2(coord.x, coord.y));
    float bottom = horizontalMean(ivec2(coord.x, coord.y + 8));

    gMeanAccumulation[gl_LocalInvocationID.x][gl_LocalInvocationID.y]      = top;
    gMeanAccumulation[gl_LocalInvocationID.x][gl_LocalInvocationID.y + 8]  = middle;
    gMeanAccumulation[gl_LocalInvocationID.x][gl_LocalInvocationID.y + 16] = bottom;

    barrier();

    const int   radius = 8;
    const float weight = (float(radius) * 2.0f + 1.0f) * (float(radius) * 2.0f + 1.0f);

    float mean = 0.0f;

    for (int y = 0; y <= 16; y++)
        mean += gMeanAccumulation[gl_LocalInvocationID.x][gl_LocalInvocationID.y + y];

    return mean / weight;
}




void main()
{
    gShouldDenoise = 0;

    barrier();

    const ivec2 size          = textureSize(uHistoryOutput, 0);
    const ivec2 currentCoord = ivec2(gl_GlobalInvocationID.xy);
    loadCache();
    float mean = computeMean(currentCoord);
}

//gl_GlobalInvocationID = gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID;
//gl_LocalInvocationIndex = gl_LocalInvocationID.z * gl_WorkGroupSize.x * gl_WorkGroupSize.y + gl_LocalInvocationID.y * gl_WorkGroupSize.x + gl_LocalInvocationID.x;